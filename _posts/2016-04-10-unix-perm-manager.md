---
layout: post
title: "Unix权限管理"
description: ""
category: Unix环境编程
tags: []
---
{% include JB/setup %}

## 概要

权限管理实际就是身份认证和访问权限校验的过程，被授权的用户可获得相应的访问权限，反之，则否。

在 Unix 中用到权限管理的场合包括：

  1. 登录
  2. 进程对文件的存取访问

第1点暂不予讨论。此处针对第2点：

身份认证的过程实际就是：“系统”校验“主体”是否符合“客体”所期望的身份的过程。
在“进程对文件的存取访问”的身份认证过程中，内核担当“系统”角色，进程为“主体”，文件则为“客体”。
那么，认证的依据是什么？主客双方都需要提供某种类型的身份凭证！
在“进程对文件的存取访问”的认证过程中，进程提供的身份凭证是有效用户ID和有效组ID；
文件提供的凭证则是属主用户ID和属主组ID。

在提供差异化权限管理的系统中，“客体”对不同“主体”的开放程度可能是不同的。
这就需要访问权限校验。访问权限校验是指：在指定身份下，“客体”是否可满足特定类型的访问申请。

## 进程权限

任意Unix进程可有如下“身份”：

  1. 实际用户ID、有效用户ID、保存的设置用户ID
  2. 实际组ID、有效组ID、保存的设置组ID

这些“身份“的访问控制函数总结如下：

``` c++
#include <unistd.h>

uid_t getuid( ); // 获取实际用户ID
uid_t geteuid( ); // 获取有效用户ID
int setuid( uid_t uid ); // 设置实际用户ID和有效用户ID
int seteuid( uid_t uid ); // 设置有效用户ID

gid_t getgid( ); // 获取实际组ID
gid_t getegid( ); // 获取有效组ID
int setgid( gid_t gid ); // 设置实际组ID和有效组ID
int setegid( gid_t gid ); // 设置有效组ID
```

`setuid` 和 `setgid` 可按规则设置调用进程的实际和有效“身份”，这些规则如下：

  1. 以 `setuid` 为例：

     1. 若调用进程具有超级用户特权，则将调用进程的实际用户ID、有效用户ID、保存的设置用户ID都设为uid
     2. 若调用进程的实际用户ID或保存的设置用户ID等于参数uid，则将调用进程的有效用户ID设置为uid

  2. `setgid` 的规则与 `setuid` 类似

## 文件权限

文件跟权限管理相关的两条属性分别是：

  1. 属主，它指明了文件的归属，包括：

     1. 用户ID
     2. 组ID

  2. 访问控制权限，它指明了文件对不同身份的进程所允许的访问操作，共包括三组：

     1. 对所属用户所允许的访问操作： -rwx
     2. 对所属组所允许的访问操作：   ----rwx
     3. 对其他用户所允许的访问操作： -------rwx

## 进程对文件的存取访问的权限校验过程

  1. 若进程有效用户ID为0，则允许访问
  2. 若进程有效用户ID等于文件所属者用户ID，则按用户访问权限位进行访问
  3. 若进程有效组ID等于文件所属者组ID，则按组访问权限位进行访问
  4. 若以上都不匹配，则按其他用户访问权限位进行访问
